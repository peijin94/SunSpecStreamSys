<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Live Spectrum Display - StreamReceiver</title>
    <style>
        html, body { 
            height:100%; 
            margin:0; 
            background:#0b0f14; 
            color:#e6edf3; 
            font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; 
        }
        
        .main-container {
            display: flex;
            height: 100vh;
            padding: 10px;
            box-sizing: border-box;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            margin-right: 20px;
            padding: 20px;  /* All sides 40px padding */
        }
        
        .canvas-label {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .canvas-label.canvas {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            background: rgba(0,100,100,0.9);
            padding: 20px 40px;
        }
        
        .frequency-range {
            position: absolute;
            font-size: 12px;
            color: #9fb0c2;
        }
        
        .frequency-range.left {
            left: 20px;
            bottom: 20px;
        }
        
        .frequency-range.right {
            right: 20px;
            bottom: 20px;
        }
        
        .time-direction {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 12px;
            color: #9fb0c2;
        }
        
        .time-arrow {
            color: #1f6feb;
            font-weight: bold;
        }
        
        canvas { 
            display: block; 
            width: 100%;
            height: 100%;
            image-rendering: pixelated; 
        }
        
        .status {
            position: relative;
            background: rgba(20,26,33,.9);
            border: 1px solid #1e2732;
            border-radius: 12px;
            padding: 12px;
            font-size: 15px;
            font-family: monospace;
            color: #9fb0c2;
            min-width: 200px;
        }
        
        .error {
            color: #f85149;
        }
        
        .success {
            color: #7ee787;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="canvas-container">
            <canvas id="view"></canvas>
            <div class="time-direction">
                <span class="time-arrow">‚Üê</span> Now
            </div>
        </div>
        
        <div class="status">
            <div>Status: <span id="status">Connecting...</span></div>
            <div>Frames: <span id="frameCount">0</span></div>
            <div>Update Rate: <span id="updateRateDisplay">4.0 fps</span></div>
            <div>Data Range: 10^4 to 10^9</div>
            <div>Last Update: <span id="lastUpdate">Never</span></div>
            <div>Detections: <span id="detectionCount">0</span></div>
            <div>Detection History: <span id="detectionHistoryCount">0</span></div>
        </div>
    </div>

    <script>
        (function(){
            const view = document.getElementById('view');
            const ctx = view.getContext('2d', { alpha:false, desynchronized:true });

            // Offscreen texture canvas for ring buffer
            let tex = document.createElement('canvas');
            let tctx = tex.getContext('2d', { alpha:false, desynchronized:true });

            // State
            let bins = 768;            // frequency bins (downsampled by factor of 4)
            let heightLines = 600;     // waterfall height (now represents time lines)
            let writeX = heightLines - 1;  // ring buffer write position (right to left)
            let running = true;
            let updateRate = 2.0;      // updates per second (every 0.5s)
            let dataMin = 1e4;         // minimum data value (10^4)
            let dataMax = 1e8;         // maximum data value (10^9)
            let freqMin = 15;          // minimum frequency in MHz
            let freqMax = 85;          // maximum frequency in MHz
            let lastData = null;
            let frameCount = 0;
            let lastDelay = 0;

            // UI elements
            const $ = id => document.getElementById(id);
            const statusEl = $('status'), frameCountEl = $('frameCount');
            const updateRateDisplayEl = $('updateRateDisplay'), lastUpdateEl = $('lastUpdate');
            const detectionCountEl = $('detectionCount'), detectionHistoryCountEl = $('detectionHistoryCount');

            // Fixed update rate - no UI controls needed
            function syncLabels(){
                updateRateDisplayEl.textContent = updateRate + ' fps';
            }

            // Resize handling
            function resize(){
                const dpr = Math.min(2, window.devicePixelRatio || 1);
                const w = Math.floor(innerWidth * dpr);
                const h = Math.floor(innerHeight * dpr);
                if (view.width !== w || view.height !== h){
                    view.width = w; view.height = h;
                }
            }
            window.addEventListener('resize', resize);
            resize();

            // Texture management
            let columnImage = null;
            function recreateTexture(){
                tex.width = heightLines;  // Width = time lines (600)
                tex.height = bins;        // Height = frequency bins (768)
                tctx.fillStyle = '#000';
                tctx.fillRect(0,0,tex.width, tex.height);
                columnImage = tctx.createImageData(1, bins);  // 1 pixel wide, 768 bins tall
                writeX = heightLines - 1;  // Start from rightmost column
            }

            // Data mapping functions
            function toIdx(v){
                if (v < dataMin) v = dataMin;
                if (v > dataMax) v = dataMax;
                const logV = Math.log(v) / Math.LN10;
                const t = (logV - Math.log(dataMin) / Math.LN10) / ((Math.log(dataMax) / Math.LN10) - (Math.log(dataMin) / Math.LN10));
                return t ;// Math.max(0, Math.min(255, Math.round(t * 255)));
            }

            // Inferno colormap function (converts intensity 0-255 to RGB)
            function infernoColormap(intensity) {
                // Inferno colormap: dark purple -> blue -> orange -> bright yellow
                const t = intensity ;
                
                if (t < 0.25) {
                    // Dark purple to blue
                    const s = t / 0.25;
                    return {
                        r: Math.round(4 * s * (1 - s) * 255),
                        g: 0,
                        b: Math.round((1 - 4 * s * (1 - s)) * 255)
                    };
                } else if (t < 0.5) {
                    // Blue to green
                    const s = (t - 0.25) / 0.25;
                    return {
                        r: 0,
                        g: Math.round(s * 255),
                        b: Math.round((1 - s) * 255)
                    };
                } else if (t < 0.75) {
                    // Green to orange
                    const s = (t - 0.5) / 0.25;
                    return {
                        r: Math.round(s * 255),
                        g: Math.round(255),
                        b: Math.round((1 - s) * 255)
                    };
                } else {
                    // Orange to bright yellow
                    const s = (t - 0.75) / 0.25;
                    return {
                        r: Math.round(255),
                        g: Math.round(255),
                        b: Math.round(s * 255)
                    };
                }
            }

            // Write data column to texture (for rolling waterfall: left to right)
            function writeRow(dataArray){
                if (!dataArray || dataArray.length !== bins) return;
                
                // Create a column of data (frequency bins as height)
                const columnData = columnImage.data;
                
                for (let y = 0; y < bins; y++){
                    // Flip the y index to invert the frequency display
                    const flippedY = bins - 1 - y;
                    const intensity = toIdx(dataArray[y]);
                    const colors = infernoColormap(intensity);
                    const q = flippedY * 4;
                    columnData[q] = colors.r;      // Red
                    columnData[q+1] = colors.g;    // Green  
                    columnData[q+2] = colors.b;    // Blue
                    columnData[q+3] = 255;         // Alpha
                }
                
                // Put the column at the current writeX position (left side)
                tctx.putImageData(columnImage, writeX, 0);
                
                // Move write position right (increment) for next column
                writeX = (writeX + 1) % heightLines;
                
                frameCount++;
                frameCountEl.textContent = frameCount;
            }

            // Render texture to view with rolling waterfall effect
            // Newest data on left, spectrum rolls right over time
            function blitToView(){
                const W = view.width, H = view.height;
                
                // Clear canvas first
                ctx.clearRect(0, 0, W, H);
                
                // Calculate proper scaling to fit the smaller plot area
                const plotWidth = W - 240;   // Account for left/right padding (40px each)
                const plotHeight = H - 120;  // Account for top/bottom padding (40px each)
                const scaleX = plotWidth / heightLines;  // Scale time (x-axis) to fit plot width
                const scaleY = plotHeight / bins;        // Scale frequency (y-axis) to fit plot height
                
                // Draw the waterfall with rolling effect in the smaller plot area
                // We need to draw the texture in two parts to create the rolling effect
                
                // Part 1: Draw the left portion (newest data)
                // This should be from writeX to heightLines-1 (left side)
                const leftPortion = heightLines - writeX;
                if (leftPortion > 0) {
                    const leftWidth = leftPortion * scaleX;
                    ctx.drawImage(tex, writeX, 0, leftPortion, bins, 
                                200, 50, leftWidth, plotHeight);  // Position with 40px padding
                }
                
                // Part 2: Draw the right portion (older data)
                // This should be from 0 to writeX-1 (right side)
                if (writeX > 0) {
                    const rightWidth = writeX * scaleX;
                    const rightX = 200 + leftPortion * scaleX;  // Position with 200px padding
                    ctx.drawImage(tex, 0, 0, writeX, bins, 
                                rightX, 50, rightWidth, plotHeight);  // Position with 200px padding
                }
                
                // Add frequency and time scale labels
                drawFrequencyScale(W, H);
                drawTimeScale(W, H);
                
                // Draw detection bounding boxes
                drawDetections(W, H);
            }
            
            // Draw frequency scale on the left (vertical)
            function drawFrequencyScale(canvasWidth, canvasHeight) {
                ctx.save();
                ctx.fillStyle = '#9fb0c2';
                ctx.font = '40px monospace';  // Increased font size
                ctx.textAlign = 'right';
                
                // Draw frequency markers vertically (15MHz at top, 85MHz at bottom)
                const frequencies = [15, 25, 35, 45, 55, 65, 75, 85];
                frequencies.forEach(freq => {
                    // Map frequency to y position (15MHz at top, 85MHz at bottom)
                    const freqRatio = (freqMax - freq) / (freqMax - freqMin);
                    const y = 50 + freqRatio * (canvasHeight - 120);  // Account for 40px padding
                    ctx.fillText(freq + 'MHz', 145, y + 4);  // Position text outside plot
                    
                    // Draw horizontal line extending across the plot
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(200, y);  // Start from plot edge (40px left padding)
                    ctx.lineTo(canvasWidth - 40, y);  // End at plot edge (40px right padding)
                    ctx.stroke();
                });
                
                ctx.restore();
            }
            
            // Draw time scale on the bottom (horizontal) - newest at left, oldest at right
            function drawTimeScale(canvasWidth, canvasHeight) {
                ctx.save();
                ctx.fillStyle = '#9fb0c2';
                ctx.font = '40px monospace';  // Increased font size
                ctx.textAlign = 'center';
                
                // Draw time markers horizontally (newest at left, oldest at right)
                const timeLabels = ['Now', '-75s', '-150s', '-225s', '-300s'];
                timeLabels.forEach((label, index) => {
                    // Map time to x position (newest = left, oldest = right)
                    const timeRatio = (timeLabels.length - 1 - index) / (timeLabels.length - 1);
                    const x = 200 + timeRatio * (canvasWidth - 240);  // Account for 40px padding
                    ctx.fillText(label, x, canvasHeight - 25);  // Position text below plot
                    
                    // Draw vertical line extending up the plot
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(x, 50);  // Start from plot edge (40px top padding)
                    ctx.lineTo(x, canvasHeight - 70);  // End at plot edge (40px bottom padding)
                    ctx.stroke();
                });
                
                ctx.restore();
            }

            // Data fetching
            async function fetchData(){
                try {
                    const response = await fetch('/live/data');
                    if (response.ok) {
                        const data = await response.json();
                        if (data && data.length > 0) {
                            lastData = data; // Store the data
                            writeRow(data);  // Write to waterfall
                            const now = new Date();
                            const timeStr = now.getUTCHours().toString().padStart(2, '0') + ':' + 
                                           now.getUTCMinutes().toString().padStart(2, '0') + ':' + 
                                           now.getUTCSeconds().toString().padStart(2, '0');
                            lastUpdateEl.textContent = timeStr + '(UTC)';
                            statusEl.textContent = 'Connected';
                            statusEl.className = 'success';
                        }
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    console.error('Error fetching data:', error);
                    statusEl.textContent = 'Connection Error';
                    statusEl.className = 'error';
                }
            }

            // Detection fetching and tracking
            let latestDetections = [];
            let detectionHistory = []; // Store detections with timestamps for shifting
            let detectionTimeWindow = 300; // Keep detections for 300 seconds (5 minutes)
            
            async function fetchDetections(){
                try {
                    const response = await fetch('/live/type3detect');
                    if (response.ok) {
                        const data = await response.json();
                        const newDetections = data.detections || [];
                        
                        if (newDetections.length > 0) {
                            console.log(`Type 3 detections: ${newDetections.length} bursts found`);
                            
                            // Clear previous round of detections when new ones arrive
                            detectionHistory = [];
                            
                            // Add timestamp to each detection and add to history
                            const currentTime = Date.now() / 1000; // Current time in seconds
                            newDetections.forEach(detection => {
                                detection.detectionTime = currentTime;
                                detectionHistory.push(detection);
                            });
                        }
                        
                        latestDetections = newDetections;
                        
                        // Update status displays
                        detectionCountEl.textContent = latestDetections.length;
                        detectionHistoryCountEl.textContent = detectionHistory.length;
                    } else {
                        console.error(`Detection fetch failed: HTTP ${response.status}`);
                    }
                } catch (error) {
                    console.error('Error fetching detections:', error);
                }
            }

            // Draw detection bounding boxes
            function drawDetections(canvasWidth, canvasHeight) {
                if (detectionHistory.length === 0) return;
                
                ctx.save();
                
                // Calculate plot area (same as waterfall)
                const plotWidth = canvasWidth - 240;   // Account for left/right padding
                const plotHeight = canvasHeight - 120; // Account for top/bottom padding
                const plotX = 200;  // Left edge of plot
                const plotY = 50;   // Top edge of plot
                
                // Calculate time scale (same as waterfall time axis)
                // Waterfall shows 300 seconds (5 minutes) of data
                const timeWindow = 300; // seconds
                const currentTime = Date.now() / 1000;
                
                detectionHistory.forEach((detection, index) => {
                    const [x, y, width, height] = detection.bbox;
                    const confidence = detection.confidence;
                    const classId = detection.class_id;
                    const className = detection.class;
                    const detectionTime = detection.detectionTime;
                    
                    // Calculate time offset from current time
                    const timeOffset = currentTime - detectionTime;
                    
                    // Skip if detection is too old (outside time window)
                    if (timeOffset > timeWindow) return;
                    
                    // Calculate X position based on time offset
                    // Newest detections (timeOffset = 0) are at the right edge
                    // Older detections shift left
                    const timeRatio = timeOffset / timeWindow; // 0 = newest, 1 = oldest
                    const timeX = - ( timeRatio) * plotWidth; //adjust the timeX to the left
                    
                    // Convert normalized coordinates to canvas coordinates
                    const canvasX = plotX + timeX + x * plotWidth;
                    const canvasY = plotY + y * plotHeight;
                    const canvasWidth = width * plotWidth;
                    const canvasHeight = height * plotHeight;
                    
                    console.log(timeOffset, timeWindow);
                    console.log(x, y, width, height);
                    console.log(canvasX, canvasY, canvasWidth, canvasHeight);
                    // Skip if detection is outside the visible area
                    if (canvasX < plotX || canvasX > plotX + plotWidth) return;
                    
                    // Set color based on class
                    let strokeColor;
                    if (classId === 0) {
                        strokeColor = '#ff0000'; // Red for type3 (class 0)
                    } else if (classId === 1) {
                        strokeColor = '#ffffff'; // White for type3b (class 1)
                    } else {
                        strokeColor = '#ffff00'; // Yellow for unknown classes
                    }
                    
                    // Draw bounding box
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 3;
                    //ctx.setLineDash([5, 5]); // Dashed line
                    ctx.strokeRect(canvasX, canvasY, canvasWidth, canvasHeight);
                    
                    // Draw confidence and class text
                    ctx.fillStyle = strokeColor;
                    ctx.font = '25px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${className} ${(confidence * 100).toFixed(1)}%`, canvasX + 2, canvasY - 5);
                    
                    // Draw detection ID
                    //ctx.fillText(`ID:${detection.id}`, canvasX + 2, canvasY + canvasHeight + 15);
                });
                
                ctx.restore();
            }

            // FPS counter and detection timing
            let lastT = performance.now(), acc=0, frames=0, lastFpsT=lastT;
            let detectionAcc = 0;
            let cleanupAcc = 0;

            // Clean up old detections periodically (backup cleanup)
            function cleanupOldDetections() {
                const currentTime = Date.now() / 1000;
                const cutoffTime = currentTime - detectionTimeWindow;
                const beforeCount = detectionHistory.length;
                detectionHistory = detectionHistory.filter(det => det.detectionTime > cutoffTime);
                const afterCount = detectionHistory.length;
                
                if (beforeCount !== afterCount) {
                    console.log(`Backup cleanup: removed ${beforeCount - afterCount} old detections. ${afterCount} remaining.`);
                }
                
                // Update status display
                detectionHistoryCountEl.textContent = detectionHistory.length;
            }

            function loop(now){
                const dt = Math.min(0.1, (now - lastT)/1000);
                lastT = now; 
                acc += dt * updateRate;
                detectionAcc += dt * 0.1; // 8 second interval (1/8 = 0.125)
                cleanupAcc += dt * 0.1; // Cleanup every 10 seconds

                if (running && acc >= 1){ 
                    fetchData(); 
                    blitToView();
                    acc -= 1; 
                }

                // Fetch detections every 8 seconds
                if (detectionAcc >= 1) {
                    fetchDetections();
                    detectionAcc -= 1;
                }

                // Clean up old detections every 10 seconds
                if (cleanupAcc >= 1) {
                    cleanupOldDetections();
                    cleanupAcc -= 1;
                }

                

                frames++;
                if (now - lastFpsT > 500){
                    const fps = Math.round(2000*frames/(now-lastFpsT))/2;
                    // fpsEl.textContent = fps + ' fps'; // Removed as per edit hint
                    lastFpsT = now; frames = 0;
                }

                requestAnimationFrame(loop);
            }

            // Initialize
            recreateTexture();
            syncLabels();
            
            // Start data fetching immediately
            fetchData();
            
            // Start detection fetching immediately
            fetchDetections();
            
            // Start render loop
            requestAnimationFrame(loop);
        })();
    </script>
</body>
</html>
